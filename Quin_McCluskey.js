// This class is used to create a solver object to minimize boolean expressions.
// Constructor Arguments:
//      1) numVarsArg: Number of input variables
//      2) minTermsArg: List of minterms (in greycode) (optional)
//      3) dontCaresArg: List of don't cares (in greycode) (optional)
//
// Properties:
//      1) result: returns the minimized expression (when called for first time it minimizes the expression; future calls return stored result)
//      2) kmap: returns the Karnaugh Map for the expression (when called for first time it calls result and then return kmap; future calls return stored result)
// 
// In result each string might contain '-', '0' or '1'. '-' means that the particular input variable is not present in that term, '0' means that the negation of that particular input variable is present in the term while '1' means that the particular input variable is present as is in that term. Each string represent one AND term. All the strings are ORed together for final expression. Thus the result is in Sum of Product form.
//
// The kmap is a list of lists. Each inner list represents the set of greycodes that constitutes one 'box' in the Karnaugh Map.
function BooleanMinimize(numVarsArg, minTermsArg = [], dontCaresArg = []){
    var __result, __kmap;

    Object.defineProperties(
        this,
        {
            'minTerms': {
                value: minTermsArg,
                enumerable: false,
                writable: false,
                configurable: true
            },

            'dontCares': {
                value: dontCaresArg,
                enumerable: false,
                writable: false,
                configurable: true
            },

            'numVars': {
                value: numVarsArg,
                enumerable: false,
                writable: false,
                configurable: true
            },

            'result': {
                enumerable: true,
                configurable: true,
                get: function(){
                    if(__result === undefined){
                        __result = BooleanMinimize.prototype.solve.call(this);
                    }

                    return __result;
                },
                set: function(val){
                    throw new Error("result cannot be assigned a value");
                }
            },

            'kmap': {
                enumerable: true,
                configurable: true,
                get: function(){
                    if(__kmap === undefined){
                        __kmap = BooleanMinimize.prototype.get_kmap.call(this);
                    }

                    return __kmap;
                },
                set: function(val){
                    throw new Error("kmap cannot be assigned a value");
                }
            }
        }
    )
}

// This function converts a given decimal number (n) to its binary equivalent in string format
// Arguments:
//      1) n: The decimal number to be converted to binary
//
// Returns:
//      The binary equivalent in string format whose length is equivalent to numVars
// 
// Example:
//      If n = 3 and numVars = 4 then it returns '0011'
BooleanMinimize.prototype.dec_to_binary_string = function(n){
    var str = n.toString(2);
    while(str.length != this.numVars){
        str = '0' + str;
    }

    return str;
};

// This function return number of set bits (ones) in 's' whiich is a binary string (like the one returned by dec_to_binary_string)
BooleanMinimize.prototype.num_set_bits = function(s){
    var ans = 0;
    for(let i = 0; i < s.length; ++i) if(s[i] === '1') ans++;

    return ans;
};

// This function performs the first step of the Quin McCluskey algorithm. It combines the given terms to generate a set of prime implicants
// Arguments:
//      1) allTerms: A list of binary strings of the terms to be combined
// 
// Returns:
//      A set of prime implicants generated by combining terms from allTerms
// 
// Example:
//      Let allTerms = ['000', '011', '100', '101', '111']
//      Then this function returns Set { '-00', '10-', '-11', '1-1' }
BooleanMinimize.prototype.get_prime_implicants = function(allTerms){
    var table = [];
    var primeImplicants = new Set();
    var reduced;

    while(1){
        for(let i = 0; i <= this.numVars; ++i) table[i] = new Set();
        for(let i = 0; i < allTerms.length; ++i) table[BooleanMinimize.prototype.num_set_bits(allTerms[i])].add(allTerms[i]);

        allTerms = [];
        reduced = new Set();

        for(let i = 0; i < table.length - 1; ++i){
            for(let str1 of table[i]){
                for(let str2 of table[i+1]){
                    let diff = -1;

                    for(let j = 0; j < this.numVars; ++j){
                        if(str1[j] != str2[j]){
                            if(diff === -1){
                                diff = j;
                            }
                            else{
                                diff = -1;
                                break;
                            }
                        }
                    }

                    if(diff !== -1){
                        allTerms.push(str1.slice(0, diff) + '-' + str1.slice(diff + 1));
                        reduced.add(str1);
                        reduced.add(str2);
                    }
                }
            }
        }

        for(let t of table){
            for(let str of t){
                if(!(reduced.has(str))) primeImplicants.add(str);
            }
        }

        if(!reduced.size) break;
    }

    return primeImplicants;
};

// This function returns 'true' if 'primeImplicant' is derived from 'minTerm'
// Arguments:
//      1) minTerm: The minterm in binary string format
//      2) primeImplcant: The prime implicant in string format
// 
// Returns:
//      true if the prime implicant has been generated by simplifying the minterm else false
BooleanMinimize.prototype.check_if_similar = function(minTerm, primeImplicant){
    for(let i = 0; i < primeImplicant.length; ++i){
        if(primeImplicant[i] !== '-' && (minTerm[i] !== primeImplicant[i])) return false;
    }

    return true;
};

// This function performs the 2nd step of the Quin McCluskey algorithm. It forms a set of prime implicants that can completely represent the set of minterms
// Arguments:
//      1) primeImplicants: A list of primeImplicants generated by simplifying the set of minterms and don't cares
//      2) minTerms: The list of minterms in binary string format
// 
// Returns:
//      The list of prime implicants that can completely cover all minterms. This is basically the minimized expression
// 
// Example:
//      Let primeImplicants = ['-00', '10-', '-11', '1-1']
//      and minTerms = ['000', '011', '100']
// 
//      Then this function returns ['-00', '-11']; which is the minimized expression
BooleanMinimize.prototype.get_essential_prime_implicants = function(primeImplicants, minTerms){
    var table = [], column;
    
    // Returns the complexity (in terms of gates) of the st of prime implicants. Every not gate contributes 1, every n input or/and gate contributes n to complexity
    function get_complexity(terms){
        var complexity = terms.length;

        for(let t of terms){
            for(let i = 0; i < t.length; ++i){
                if(t[i] !== '-'){
                    complexity++;
                    if(t[i] === '0') complexity++;
                }
            }
        }

        return complexity;
    }

    // This function is used to check if set 'sub' is a subset of set 'sup'
    // Arguments:
    //      1) sub: The supposed subset
    //      2) sup: The supposed superset
    // 
    // Returns:
    //      true if sub is a subset (<=) of sup
    function isSubset(sub, sup){
        for(let i of sub){
            if(!(sup.has(i))) return false;
        }

        return true;
    }
    
    // Forming the chart to get information about what minterms each prime implicant covers
    for(let m of minTerms){
        column = [];

        for(let i = 0; i < primeImplicants.length; ++i){
            if(BooleanMinimize.prototype.check_if_similar(m, primeImplicants[i])){
                column.push(i);
            }
        }

        table.push(column);
    }

    var possibleSets = [], tempSets;

    // Forming a list of set of prime implicants that can completely cover all minterms
    for(let i of table[0]){
        possibleSets.push(new Set([i]));
    }

    for(let i = 1; i < table.length; ++i){
        tempSets = [];
        for(let s of possibleSets){
            for(let p of table[i]){
                let x = new Set(s);
                x.add(p);
                let append = true;

                for(let j = tempSets.length - 1; j >= 0; --j){
                    if(isSubset(x, tempSets[j])){
                        tempSets.splice(j, 1);
                    }
                    else{
                        append = false;
                    }
                }

                if(append){
                    tempSets.push(x);
                }
            }

            possibleSets = tempSets;
        }
    }

    var essentialImplicants, minComplexity = 1e9;

    // Selecting the simplest set of prime implicants from the list of set of prime implicants that can completely cover all minterms
    for(let s of possibleSets){
        let p = [];
        for(let i of s){
            p.push(primeImplicants[i]);
        }
        let comp = get_complexity(p);
        if(comp < minComplexity){
            essentialImplicants = p;
            minComplexity = comp;
        }
    }

    return essentialImplicants;
};

// This function is the wrapper function to implement Quin McCluskey algorithm. It calls the functions that implement the 1st and 2nd steps and returns the final result.
BooleanMinimize.prototype.solve = function(){
    // If the final value of the expression is always 0
    if(this.minTerms.length === 0){
        return ['fallacy'];
    }
    // If the final value of the expression is always 1
    // Note: Bit operations have not been used for 2^(this.numVars) so as to not place an upperbound on numVars since javascript performs all bit operations on 32 bit integers.
    else if(this.minTerms.length + this.dontCares.length === Math.pow(2, this.numVars)){
        return ['tautology'];
    }

    var minTerms = this.minTerms.map(BooleanMinimize.prototype.dec_to_binary_string.bind(this));
    var dontCares = this.dontCares.map(BooleanMinimize.prototype.dec_to_binary_string.bind(this));

    return this.get_essential_prime_implicants(
        Array.from(this.get_prime_implicants(minTerms.concat(dontCares))),
        minTerms
    );
};

// This function returns the Karnaugh Map for the boolean expression.
// Returns:
//      A list of list of terms where each inner list represents one 'box' in the map.
BooleanMinimize.prototype.get_kmap = function(){
    var minimized = this.result, kmap = [];
    var terms = this.minTerms.concat(this.dontCares)
    var binTerms = terms.map(BooleanMinimize.prototype.dec_to_binary_string.bind(this))

    for(let p of minimized){
        let grp = [];
        for(let i = 0; i < binTerms.length; ++i){
            if(BooleanMinimize.prototype.check_if_similar(binTerms[i], p)) grp.push(terms[i]);
        }

        kmap.push(grp);
    }

    return kmap;
};